<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><link rel="preload" href="/_next/341aef1d-112b-475c-ab10-37b4e03e1201/page/documentation/api.js" as="script"/><link rel="preload" href="/_next/341aef1d-112b-475c-ab10-37b4e03e1201/page/_error.js" as="script"/><link rel="preload" href="/_next/f9f094dc267efb10ffe2a9c5331c7ae4/app.js" as="script"/><style>
* {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  font-size: 13px;
}

body {
  background-color: #F1F1F1;
}
</style><style></style><title>Operational UI</title><meta name="description" value="Building blocks for effective operational interfaces"/><meta name="keywords" value="UI, design systems, React, components, operational"/><meta name="viewport" content="user-scalable=1, width=device-width, initial-scale=1"/><link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.0.0/codemirror.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.0.0/theme/mbo.min.css"/><link rel="apple-touch-icon" sizes="57x57" href="/static/favicons/apple-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="/static/favicons/apple-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="/static/favicons/apple-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="/static/favicons/apple-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="/static/favicons/apple-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="/static/favicons/apple-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="/static/favicons/apple-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="/static/favicons/apple-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="/static/favicons/apple-icon-180x180.png"/><link rel="icon" type="image/png" sizes="192x192" href="/static/favicons/android-icon-192x192.png"/><link rel="icon" type="image/png" sizes="32x32" href="/static/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/static/favicons/favicon-96x96.png"/><link rel="icon" type="image/png" sizes="16x16" href="/static/favicons/favicon-16x16.png"/><link rel="manifest" href="/static/favicons/manifest.json"/><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.0.0/codemirror.min.js"></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.0.0/mode/javascript/javascript.min.js"></script></head><body><div><div id="__next"><div data-reactroot=""><div class="css-1xi7ava"><div class="css-18d5o69"></div><div class="css-18d5o69"></div><div class="css-18d5o69"></div><div class="css-18d5o69"></div></div></div></div><div id="__next-error"></div></div><div><script>
          __NEXT_DATA__ = {"props":{"content":"\n## Stateless and controlled\n\nComponents rely on very little local state, limited only to holding transient UI state (e.g. whether a dialog box is expanded), filter/autocomplete values and intermediate data entry results.\n\nComponents whose main concern is data entry typically provide a *value* and *onChange* props. The parent component must own this piece of state and define how it reacts to its changes by wiring up these props.\n\nSome examples:\n\n    \u003cInput value=\"MyName\" onChange={newValue =\u003e { /* */ }/\u003e\n    \u003cDatePicker start=\"2013-10-02\" end={null} onChange={({ start, end }) =\u003e { /* */ }/\u003e\n\nNotice how *value* is often more complex, and thus named differently to keep props flat. As a general pattern, the data structure passed back through *onChange* mymics the structure passed down, to the extent it can be made clear using JSX syntax.\n\n## Makes use of dedicated child components to define structure\n\nOne could define a menu in two ways:\n\n    const Menu1 = () =\u003e \u003cMenu links={[{ label: \"Link1\", url: \"/link1\" }, { label: \"Link2\", url: \"/link2\" }]}/\u003e\n    const Menu2 = () =\u003e\n      \u003cMenu\u003e\n        \u003cMenuLink label=\"Link1\" url=\"/link1\"/\u003e\n        \u003cMenuLink label=\"Link2\" url=\"/link2\"/\u003e\n      \u003c/Menu\u003e\n\nThis library heavily opts for the latter, keeping content more customizable, and breaking down responsibilities of both styling and customization options to multiple components. This heavily component-based styling philosophy emerges from the internal implementation of the component styles themselves. Replicating this styling approach in larger applications using this project will make sure styles play nicely together.\n\n## Theming\n\nMost components rely on a theme object, the use of which the library mandates, as follows:\n\n    import { operationalTheme, Button } from \"@operational/components\"\n    import glamorous, { ThemeProvider } from \"glamorous\"\n\n    render(\u003cThemeProvider theme={operationalTheme}\u003e\u003cButton\u003eHello\u003c/Button\u003e\u003c/ThemeProvider\u003e\n\nYou can of course, define your own theme based on the operationalTheme structure. Since the theme structure still changes significantly, more detailed docs will be arriving later.\n\n## Overrides\n\nui-components is fairly opinionated, designed to get effective and sensibly designed operational interfaces running in the least amount of time and code involved. As your application grows and needs become more specialized, you'll likely need to do customizations and overrides.\n\nTwo override props are provided on all components, an additional *className* string and a glamor style object under the name *css*, as follows:\n\n    \u003cButton className=\"solid-button\" css={{ color: \"red\": \"\u0026:hover\": { color: \"blue\" }}}/\u003e\n\nSome components expose similar props you can use to style key internal components, such as the content panel of a modal, trough related props *childClassName* and *childCss*.\n\nNote that inline styles passed in through the *style* prop are ignored in order to discourage ultimate escape hatches that override the cascade. \n\n## All-JS, all-React\n\nComponents tap all the way into advanced features of its significant dependencies, React and glamorous. Custom-defined CSS class names are avoided as much as possible over granular, parameterized styled components. Several components rely on React's event delegation, child manipulation through *React.Children.map*, and there are plans underway to introduce error boundaries and portals.\n\nBut that doesn't mean the project has to be used this way: you can attach custom class names and style overrides as you see fit, integrate with third-party libraries, and provide custom React content inside components. The hashed class names inside components will make sure you can plug other projects and technologies in and stay conflict-free. \n\n"},"pathname":"/documentation/api","query":{"title":"API Design"},"buildId":"341aef1d-112b-475c-ab10-37b4e03e1201","buildStats":{"app.js":{"hash":"f9f094dc267efb10ffe2a9c5331c7ae4"}},"assetPrefix":"","nextExport":true,"err":null,"ids":[],"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }
        </script><script async="" id="__NEXT_PAGE__/documentation/api" type="text/javascript" src="/_next/341aef1d-112b-475c-ab10-37b4e03e1201/page/documentation/api.js"></script><script async="" id="__NEXT_PAGE__/_error" type="text/javascript" src="/_next/341aef1d-112b-475c-ab10-37b4e03e1201/page/_error.js"></script><div></div><script type="text/javascript" src="/_next/f9f094dc267efb10ffe2a9c5331c7ae4/app.js" async=""></script></div></body></html>